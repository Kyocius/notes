## 数组的顺序存储结构

### 一维数组

$$
\begin{aligned}
loc(a[i])&=b+(i-1)c \\
         &=b-c+i*c  \\
         &=C_0+C_1*i
\end{aligned}
$$

### 二维数组

$$
\begin{aligned}
loc(a[i,j])&=b+[(i-1)*n+(j-1)]*c \\
               &=C_0+C_1*i+C_2*j
\end{aligned}
$$

### 三维数组

$$
\begin{aligned}
loc(a[i,j])&=b+[(i-1)*n * m +(j-1) * m+ (k-1)]*c \\
               &=C_0+C_1*i+C_2*j + C_3*k
\end{aligned}
$$



### d 维数组

$$
\begin{aligned}
loc(a[i1, i2, ..., id])=C_0+C_1*i_1+C_2*i_2+...+C_d*i_d
\end{aligned}
$$

- C 语言定义多维数组时，最右边的下标先变化，即行优先顺序
- C语言函数实参，必须提供除最左边一维外的所有维的长度，且与形参匹配



??? success
	**例题：**设计一个算法，将含有 n 个元素的整形数组 A[0..n-1] 的元素循环右移 m 位(1≤m≤n)，要求空间复杂度为 O(1)

    思路：
    
    1. 设 Y 为后 m 位，X 为前 n-m 位
    
    2. 分别反转，得到 $X^{-1}Y^{-1}$
    
    3. 再整体反转，得到结果 $(X^{-1}Y{-1})^{-1}$
    ```c
    void Reverse(int A[], int i, int j) //置逆A[i..j]
    {
    int k, tmp;
    for (k=0; k<(j-i+1)/2; k++)
        {
        tmp = A[i+k];
        A[i+k] = A[j-k];
        A[j-k] = tmp;
        }
    }
    
    void RightMove(int A[], int n, int m)
    {
        Reverse(A, 0, n-m-1);
        Reverse(A, n-m, n-1);
        Reverse(A, 0, n-1);
    }
    ```

## 矩阵的压缩存储

